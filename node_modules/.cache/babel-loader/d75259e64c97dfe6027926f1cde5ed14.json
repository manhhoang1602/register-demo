{"ast":null,"code":"import _classCallCheck from \"/home/hoangdev/Desktop/front.test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/hoangdev/Desktop/front.test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport debounce$1 from 'lodash/debounce';\nimport { stackedContent } from '../breakpoints.js';\nimport { spacingLoose } from '@shopify/polaris-tokens';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { getRectForNode } from '../geometry.js';\nvar SIXTY_FPS = 1000 / 60;\n\nvar StickyManager = /*#__PURE__*/function () {\n  function StickyManager(container) {\n    var _this = this;\n\n    _classCallCheck(this, StickyManager);\n\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce$1(function () {\n      _this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce$1(function () {\n      _this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  _createClass(StickyManager, [{\n    key: \"registerStickyItem\",\n    value: function registerStickyItem(stickyItem) {\n      this.stickyItems.push(stickyItem);\n    }\n  }, {\n    key: \"unregisterStickyItem\",\n    value: function unregisterStickyItem(nodeToRemove) {\n      var nodeIndex = this.stickyItems.findIndex(function (_ref) {\n        var stickyNode = _ref.stickyNode;\n        return nodeToRemove === stickyNode;\n      });\n      this.stickyItems.splice(nodeIndex, 1);\n    }\n  }, {\n    key: \"setContainer\",\n    value: function setContainer(el) {\n      this.container = el;\n\n      if (isDocument(el)) {\n        this.setTopBarOffset(el);\n      }\n\n      this.container.addEventListener('scroll', this.handleScroll);\n      window.addEventListener('resize', this.handleResize);\n      this.manageStickyItems();\n    }\n  }, {\n    key: \"removeScrollListener\",\n    value: function removeScrollListener() {\n      if (this.container) {\n        this.container.removeEventListener('scroll', this.handleScroll);\n        window.removeEventListener('resize', this.handleResize);\n      }\n    }\n  }, {\n    key: \"manageStickyItems\",\n    value: function manageStickyItems() {\n      var _this2 = this;\n\n      if (this.stickyItems.length <= 0) {\n        return;\n      }\n\n      var scrollTop = this.container ? scrollTopFor(this.container) : 0;\n      var containerTop = getRectForNode(this.container).top + this.topBarOffset;\n      this.stickyItems.forEach(function (stickyItem) {\n        var handlePositioning = stickyItem.handlePositioning;\n\n        var _this2$evaluateSticky = _this2.evaluateStickyItem(stickyItem, scrollTop, containerTop),\n            sticky = _this2$evaluateSticky.sticky,\n            top = _this2$evaluateSticky.top,\n            left = _this2$evaluateSticky.left,\n            width = _this2$evaluateSticky.width;\n\n        _this2.updateStuckItems(stickyItem, sticky);\n\n        handlePositioning(sticky, top, left, width);\n      });\n    }\n  }, {\n    key: \"evaluateStickyItem\",\n    value: function evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n      var stickyNode = stickyItem.stickyNode,\n          placeHolderNode = stickyItem.placeHolderNode,\n          boundingElement = stickyItem.boundingElement,\n          offset = stickyItem.offset,\n          disableWhenStacked = stickyItem.disableWhenStacked;\n\n      if (disableWhenStacked && stackedContent().matches) {\n        return {\n          sticky: false,\n          top: 0,\n          left: 0,\n          width: 'auto'\n        };\n      }\n\n      var stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacingLoose, 10) : this.getOffset(stickyNode);\n      var scrollPosition = scrollTop + stickyOffset;\n      var placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n      var top = containerTop + stickyOffset;\n      var width = placeHolderNode.getBoundingClientRect().width;\n      var left = placeHolderNode.getBoundingClientRect().left;\n      var sticky;\n\n      if (boundingElement == null) {\n        sticky = scrollPosition >= placeHolderNodeCurrentTop;\n      } else {\n        var _stickyNode$firstElem;\n\n        var stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) == null ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n        var stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n        sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n      }\n\n      return {\n        sticky: sticky,\n        top: top,\n        left: left,\n        width: width\n      };\n    }\n  }, {\n    key: \"updateStuckItems\",\n    value: function updateStuckItems(item, sticky) {\n      var stickyNode = item.stickyNode;\n\n      if (sticky && !this.isNodeStuck(stickyNode)) {\n        this.addStuckItem(item);\n      } else if (!sticky && this.isNodeStuck(stickyNode)) {\n        this.removeStuckItem(item);\n      }\n    }\n  }, {\n    key: \"addStuckItem\",\n    value: function addStuckItem(stickyItem) {\n      this.stuckItems.push(stickyItem);\n    }\n  }, {\n    key: \"removeStuckItem\",\n    value: function removeStuckItem(stickyItem) {\n      var nodeToRemove = stickyItem.stickyNode;\n      var nodeIndex = this.stuckItems.findIndex(function (_ref2) {\n        var stickyNode = _ref2.stickyNode;\n        return nodeToRemove === stickyNode;\n      });\n      this.stuckItems.splice(nodeIndex, 1);\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(node) {\n      if (this.stuckItems.length === 0) {\n        return 0;\n      }\n\n      var offset = 0;\n      var count = 0;\n      var stuckNodesLength = this.stuckItems.length;\n      var nodeRect = getRectForNode(node);\n\n      while (count < stuckNodesLength) {\n        var stuckNode = this.stuckItems[count].stickyNode;\n\n        if (stuckNode !== node) {\n          var stuckNodeRect = getRectForNode(stuckNode);\n\n          if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n            offset += getRectForNode(stuckNode).height;\n          }\n        } else {\n          break;\n        }\n\n        count++;\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"isNodeStuck\",\n    value: function isNodeStuck(node) {\n      var nodeFound = this.stuckItems.findIndex(function (_ref3) {\n        var stickyNode = _ref3.stickyNode;\n        return node === stickyNode;\n      });\n      return nodeFound >= 0;\n    }\n  }, {\n    key: \"setTopBarOffset\",\n    value: function setTopBarOffset(container) {\n      var topbarElement = container.querySelector(\":not(\".concat(scrollable.selector, \") \").concat(dataPolarisTopBar.selector));\n      this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n    }\n  }]);\n\n  return StickyManager;\n}();\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  var rect1Left = rect1.left;\n  var rect1Right = rect1.left + rect1.width;\n  var rect2Left = rect2.left;\n  var rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };","map":{"version":3,"sources":["/home/hoangdev/Desktop/front.test/node_modules/@shopify/polaris/dist/esm/utilities/sticky-manager/sticky-manager.js"],"names":["debounce$1","stackedContent","spacingLoose","scrollable","dataPolarisTopBar","getRectForNode","SIXTY_FPS","StickyManager","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","stickyItem","push","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","evaluateStickyItem","sticky","left","width","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","_stickyNode$firstElem","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"mappings":"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","sourcesContent":["import debounce$1 from 'lodash/debounce';\nimport { stackedContent } from '../breakpoints.js';\nimport { spacingLoose } from '@shopify/polaris-tokens';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { getRectForNode } from '../geometry.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce$1(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce$1(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacingLoose, 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) == null ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"]},"metadata":{},"sourceType":"module"}